version = '1.0'
sourceCompatibility = 1.8
targetCompatibility = 1.8

configurations {
    compile
}

ext.isProjectJar = { String jarName ->
    for (def subProject : project.parent.subprojects) {
        def projectJarName = subProject.name + ".jar"
        if (projectJarName.equals(jarName)) {
            return true
        }
    }

    return false
}

task copyDependencies {
    doLast {
        copy {
            from({
                configurations.compile.findAll {
                    !isProjectJar(it.name)
                }
            })

            into project.buildDir.path + "/dependencies/"
            include "**/*.jar"
        }
    }
}

task copyStartScript {
    doLast {
        copy {
            from "start.sh"
            into project.buildDir.path + "/libs/"
        }
    }
}

//create a single Jar with all dependencies
task fatJar(type: Jar) {

    zip64 true

    manifest {
        attributes 'Implementation-Title': 'Gradle Jar File Example',
                'Implementation-Version': version,
                'Main-Class': 'com.mkyong.DateUtils'
    }
    baseName = project.name + '-all'
    from({
        configurations.compile.findAll {
            isProjectJar(it.name)
        }.collect { it.isDirectory() ? it : zipTree(it) }
    })
    with jar
}

buildscript {
    repositories {
        flatDir dirs: project.buildDir.path + '/../../gradle/proguardlib'
    }
    dependencies {
        classpath ':proguard:'
    }
}

task myProguardTask(type: proguard.gradle.ProGuardTask) {
//    configuration 'proguard-rules.pro'

    injars project.buildDir.path + '/libs/'
    outjars project.buildDir.path + '/obfuscate/'

    libraryjars project.buildDir.path + '/dependencies/'
    // Automatically handle the Java version of this build.
    if (System.getProperty('java.version').startsWith('1.')) {
        // Before Java 9, the runtime classes were packaged in a single jar file.
        libraryjars "${System.getProperty('java.home')}/lib/rt.jar"
    } else {
        // As of Java 9, the runtime classes are packaged in modular jmod files.
        libraryjars "${System.getProperty('java.home')}/jmods/java.base.jmod", jarfilter: '!**.jar', filter: '!module-info.class'
        //libraryjars "${System.getProperty('java.home')}/jmods/....."
    }

    // Save the obfuscation mapping to a file, so we can de-obfuscate any stack
    // traces later on. Keep a fixed source file attribute and all line number
    // tables to get line numbers in the stack traces.
    // You can comment this out if you're not interested in stack traces.

    printmapping project.buildDir.path + '/out.map'
//    keepparameternames
    renamesourcefileattribute 'SourceFile'
    keepattributes 'Exceptions,InnerClasses,Signature,Deprecated,SourceFile,LineNumberTable,EnclosingMethod'

    // Preserve all annotations.

//    keepattributes '*Annotation*'

    // Preserve all public classes, and their public fields and
    // methods.

    keep 'public class * { \
        public *; \
    }'

    // Preserve all .class method names.

    keepclassmembernames 'class * { \
        java.lang.Class class$(java.lang.String); \
        java.lang.Class class$(java.lang.String, boolean); \
    }'

    // Preserve all native method names and the names of their classes.

    keepclasseswithmembernames 'class * { \
        native <methods>; \
    }'

    // Preserve the special static methods that are required in all enumeration
    // classes.

    keepclassmembers allowoptimization: true, 'enum * { \
        public static **[] values(); \
        public static ** valueOf(java.lang.String); \
    }'

    // Explicitly preserve all serialization members. The Serializable interface
    // is only a marker interface, so it wouldn't save them.
    // You can comment this out if your library doesn't use serialization.
    // If your code contains serializable classes that have to be backward
    // compatible, please refer to the manual.

    keepclassmembers 'class * implements java.io.Serializable { \
        static final long serialVersionUID; \
        static final java.io.ObjectStreamField[] serialPersistentFields; \
        private void writeObject(java.io.ObjectOutputStream); \
        private void readObject(java.io.ObjectInputStream); \
        java.lang.Object writeReplace(); \
        java.lang.Object readResolve(); \
    }'

    // Your library may contain more items that need to be preserved;
    // typically classes that are dynamically created using Class.forName:

    // keep 'public class com.example.MyClass'
    // keep 'public interface com.example.MyInterface'
    // keep 'public class * implements com.example.MyInterface'
}

task buildSingleProject {
    doLast {
        print System.getProperty('java.version')
    }
}

fatJar.dependsOn copyDependencies
fatJar.dependsOn copyStartScript

myProguardTask.dependsOn fatJar
buildSingleProject.dependsOn myProguardTask